package awsips

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

const (
	DefaultFromPortForStack = "1"
	DefaultToPortForStack   = "65535"
)

type Output struct {
	Result *Result
}

func (o *Output) Files(regionFilters, serviceFilters *string) error {

	filter := o.filter(regionFilters, serviceFilters)

	for service, regionTree := range filter {

		for region, ips := range regionTree {

			file := fmt.Sprintf("%s.json", id(service, region))

			if output, err := format(ips); err != nil {
				return err
			} else if err := ioutil.WriteFile(file, []byte(output), 0644); err != nil {
				return err
			}

		}

	}

	return nil

}

func (o *Output) Regions() (string, error) {
	return format(o.Result.Regions())
}

func (o *Output) Services() (string, error) {
	return format(o.Result.Services())
}

func (o *Output) Stack(regionFilters, serviceFilters, portSpecs *string) (string, error) {

	filter := o.filter(regionFilters, serviceFilters)
	ports := split(portSpecs)

	no := N()

	fmt.Println()

	no.L("AWSTemplateFormatVersion", "2010-09-09")
	no.L("Description", fmt.Sprintf("Ingress Security Group via %s", strings.Join(os.Args, " ")))

	pa := no.N("Parameters")

	pa.N("vpc").
		L("Type", "String")

	op := no.N("Outputs")

	for service, regionTree := range filter {

		for region, _ := range regionTree {
			id := id(service, region)
			op.N(id).N("Value").L("Ref", id)
		}

	}

	re := no.N("Resources")

	for service, regionTree := range filter {

		for region, ips := range regionTree {

			var (
				sgi []map[string]interface{}
				add = func(ip, proto, from, to string) {

					sgi = append(sgi, map[string]interface{}{
						"CidrIp":     ip,
						"IpProtocol": proto,
						"FromPort":   from,
						"ToPort":     to,
					})

				}
			)

			for _, ip := range ips {

				if len(ports) == 0 {
					add(ip, "tcp", DefaultFromPortForStack, DefaultToPortForStack)
				} else {

					for _, port := range ports {
						add(ip, "tcp", port, port)
					}

				}

				id := id(service, region)
				sg := re.N(id)

				sg.L("Type", "AWS::EC2::SecurityGroup").
					N("Properties").
					L("GroupDescription", fmt.Sprintf("%s %s for %v)", service, region, ports)).
					L("SecurityGroupIngress", sgi).
					N("VpcId").L("Ref", "vpc")

				m := sg.N("Metadata")

				m.L("Comment", "Automatically generated by github.com/kreuzwerker/awsips")
				m.L("CreateDate", o.Result.CreateDate)
				m.L("SyncToken", o.Result.SyncToken)

			}

		}

	}

	return format(no)

}

func (o *Output) Tree(regionFilters, serviceFilters *string) (string, error) {
	filter := o.filter(regionFilters, serviceFilters)
	return format(filter)
}

func (o *Output) filter(regionFilters, serviceFilters *string) ServiceTree {

	var (
		rf = split(regionFilters)
		sf = split(serviceFilters)
	)

	return o.Result.Filter(rf, sf)

}

func format(v interface{}) (string, error) {
	out, err := json.MarshalIndent(v, "", "    ")
	return string(out), err
}

// id converts a given service / region tuple to a string that is a
// valid CloudFormation logical-id.
func id(service, region string) string {

	var (
		cc     []string
		id     = strings.Join([]string{service, region}, "_")
		upcase bool
	)

	for _, e := range id {

		if upcase == true {
			cc = append(cc, strings.ToUpper(string(e)))
			upcase = false
		} else if e == '_' || e == '-' {
			upcase = true
		} else {
			cc = append(cc, strings.ToLower(string(e)))
		}

	}

	return strings.Join(cc, "")

}

// split creates a string slice out of a comma-separated list of
// strings
func split(f *string) []string {

	if *f == "" {
		return []string{}
	} else {
		return strings.Split(*f, ",")
	}

}
